### 原型模式

原型模式实际上与对象的拷贝息息相关，原型模式使用原型实例指定待创建对象的类型，并且通过复制这个原型来创建新的对象。也就是说，原型对象作为模板，通过克隆操作，来产生更多的对象，就像细胞的复制一样。

开始之前，我们先介绍一下深拷贝和浅拷贝：

* 浅拷贝：对于基本数据类型，会直接复制值给拷贝对象；对于引用类型，只会复制对象的地址，对象中修改该成员变量会影响到另一个对象的该成员变量值。

* 深拷贝：对于基本数据类型，其中一个对象修改该值，不会影响另外一个（和浅拷贝一样）

在Java中，我们就可以使用Cloneable接口提供的拷贝机制，来实现原型模式：

```java
public class Student implements Cloneable {   //注意需要实现Cloneable接口
    @Override
    public Object clone() throws CloneNotSupportedException {   //提升clone方法的访问权限
        return super.clone();
    }
}
```

接着我们来看看克隆的对象是不是原来的对象：

```java
public class Main {
    public static void main(String[] args) {
        Student student0 = new Student();
        Student student1 = (Student) student0.clone();
        System.out.println(student0);
        System.out.println(student1);
    }
}
```

可以看到，通过clone()方法克隆的对象并不是原来的对象，我们来看看如果对象内部有属性会不会一起进行克隆：

```java
public class Student implements Cloneable {

    String name;

    public Student(String name) {
        this.name = name;
    }

    public String getName() {
        return name;
    }

    @Override
    public Object clone() throws CloneNotSupportedException {
        return super.clone();
    }
}
```

```java
public class Main {
    public static void main(String[] args) throws CloneNotSupportedException {
        Student student0 = new Student("小明");
        Student student1 = (Student) student0.clone();
        System.out.println(student0.getName() == student1.getName());
    }
}
```

可以看到，虽然Student对象成功拷贝，但是其内层对象并没有进行拷贝，依然只是对象引用的复制，所以Java为我们提供的clone方法只会进行浅拷贝。那么如何才能实现深拷贝呢？

```java
public class Main {
    @Override
    public Object clone() throws CloneNotSupportedException {   //这里我们改进一下，针对成员变量也进行拷贝
        Student student = (Student) super.clone();
        student.name = new String(name);
        return student;   //成员拷贝完成后，再返回
    }
}
```

这样，我们就实现了深拷贝。